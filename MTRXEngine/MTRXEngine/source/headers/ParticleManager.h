/*
	Author: Mohamed Kazma
	Description: A manager that will hold all particles in the game world and do what is necessary to
	update said particles and communicate with the collision detection and resolution system
	to resolve collisions contacts and other physics simulations
*/

#pragma once

#include <entities/Particle.h>
#include <ParticleCollisionResolver.h>
#include <forceGenerators/ForceGenerationRegistry.h>
#include <ParticleCollision.h>
#include <ParticleCollisionGenerator.h>

namespace MTRX
{
	// A struct that holds all the force generators of a certain particle
	struct ParticleForceGenerators
	{
		Particle* particle;
		ForceGenerationRegistry* registry;
	};

	class ParticleManager : public IUpdateable
	{
	public:
		std::list<Particle*> particles; // All the particles of the game world since we will have a dynamic amount of them we might need a dynamic structure
		std::list<ParticleCollision*> particleCollisions; // These are the collision events generated by the collision handler and resolved by the resolver
		std::list<ParticleForceGenerators*> forceGenerationRegistry; // Store the particles to force generators that they own
		std::list<ParticleCollisionGenerator*> particleCollisionGenrators; // This will store all the collision generators
		ParticleCollisionResolver collisionResolver; // We will need a collision resolver system
		unsigned int maxContacts; // The maximum number of contacts that we will handle at a current frame
		unsigned int numIterations; // The number of iterations of resolutions that we want
		
		ParticleManager(unsigned int maxContacts, unsigned int numIterations);
		~ParticleManager();

		// Generator contact collisions
		unsigned int GenerateCollisions();
		// Update call for each frame
		virtual void PhysicsUpdate();
		// Updates all particles
		void UpdateParticles();
		// Updates all forces with all particles
		void UpdateForces();
	};
}
